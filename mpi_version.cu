/**

Genetic algorithm for finding function aproximation. GPU accelerated version

Given data points {x, f(x)+noise} generated by noisy polynomial function
f(x) = c3*x^3 + c2*x^2 + c1*x + c0,
find unknown parameters c1, c2, c3 and c0.


Inputs:
• The set of points on a surface (500–1000);
• The size of population P (1000–2000);
• E_m , D_m – mean and variance for Mutation to generate the random number of mutated genes;
• maxIter - the maximum number of generations, 
  maxConstIter - the maximum number of generations with constant value of the best fitness.

Outputs:
• The time of processing on GPU;
• The set of coefficients of the polynomial that approximates the given set of points;
• The best fitness value;
• The last generation number (number of evaluated iterations).
*/

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <time.h>
#include <algorithm>

#include <cuda.h>
#include <curand.h>
#include <curand_kernel.h>
#include <thrust/sort.h>
#include <thrust/device_ptr.h>

#include "mpi_version.h"

#include "config.h"
#include "check.h"
#include "kernels.h"

using namespace std;

#define THREAD 128
#define BLOCK (POPULATION_SIZE/THREAD)

// Override cudaMalloc with our function call so that thrust::sort_by_key
// does not allocate/free working memory every iteration
extern __thread bool cudaMallocReuse;

void check_cuda_error(const char *message)
{
        cudaError_t err = cudaGetLastError();
            if (err!=cudaSuccess){
             printf("\033[31mERROR: %s: %s\n\033[0m", message, cudaGetErrorString(err));
             exit(1);
            }
}

/*
    ------------------------
    | Main body of the GA  |
    ------------------------

    Computes approximation of given points
*/
void computeGA(float *points, int deviceID,
               float *solution, float *bestFitness_o, int *genNumber_o, double *time_o)
{

    cudaSetDevice(deviceID);
    check_cuda_error("Setting device");

    /**
        Allocations of memory
    */
    //device memory for holding input points
    float *points_dev;
    cudaMalloc(&points_dev, 2*N_POINTS*sizeof(float)); // [x, f(x)+err]
    check_cuda_error("Error allocating device memory");
    cudaMemcpy(points_dev, points, 2*N_POINTS*sizeof(float), cudaMemcpyHostToDevice);
    check_cuda_error("Error copying data");

    //arrays to hold old and new population    
    float *population_dev;
    cudaMalloc(&population_dev, POPULATION_SIZE * INDIVIDUAL_LEN * sizeof(float));
    check_cuda_error("Error allocating device memory");

    float *newPopulation_dev;
    cudaMalloc(&newPopulation_dev, POPULATION_SIZE * INDIVIDUAL_LEN * sizeof(float));
    check_cuda_error("Error allocating device memory");

    //arrays that keeps fitness of individuals withing current population
    float *fitness_dev;
    cudaMalloc(&fitness_dev, POPULATION_SIZE*sizeof(float));
    check_cuda_error("Error allocating device memory");

    //key value for sorting
    int *indexes_dev;
    cudaMalloc(&indexes_dev, POPULATION_SIZE*sizeof(int));
    check_cuda_error("Error allocating device memory");

    curandState *state_random;
    cudaMalloc((void **)&state_random,POPULATION_SIZE * INDIVIDUAL_LEN * sizeof(curandState));
    check_cuda_error("Allocating memory for curandState");

    //mutation probabilities
    float* mutIndivid_d;
    cudaMalloc((void **) &mutIndivid_d,POPULATION_SIZE*sizeof(float));
    check_cuda_error("Allocating memory in mutIndivid_d");

    float* mutGene_d;
    cudaMalloc((void **)&mutGene_d,POPULATION_SIZE*INDIVIDUAL_LEN*sizeof(float));
    check_cuda_error("Allocating memory in mutGene_d");

    //create PRNG for generating mutation probabilities
    curandGenerator_t generator;

    curandCreateGenerator(&generator, CURAND_RNG_PSEUDO_DEFAULT);
    check_cuda_error("Error in curandCreateGenerator");

    curandSetPseudoRandomGeneratorSeed(generator, 0);
    check_cuda_error("Error in curandSeed");

    //recast device pointers into thrust copatible pointers
    thrust::device_ptr<int> indexes_thrust = thrust::device_pointer_cast(indexes_dev);
    thrust::device_ptr<float> fitnesses_thrust = thrust::device_pointer_cast(fitness_dev);


    //Initialize first population (with zeros or some random values)
    initCurand<<<BLOCK, THREAD>>>(state_random);
    initPopulation<<<BLOCK, THREAD>>>(population_dev, state_random); //<-5, 5>
    cudaDeviceSynchronize();

    /**
        Main GA loop
    */
    int t1 = clock(); //start timer

    int generationNumber = 0;
    int noChangeIter = 0;

    float bestFitness = INFINITY;
    float previousBestFitness = INFINITY;

	while ( (generationNumber < maxGenerationNumber)
            /*&& (bestFitness > targetErr)
            && (noChangeIter < maxConstIter)*/ )
	{
		generationNumber++;
	
        /** crossover first half of the population and create new population */
		crossover<<<BLOCK,THREAD>>>(population_dev, state_random);
        cudaDeviceSynchronize();

		/** mutate population and childrens in the whole population*/
        generateMutProbab(&mutIndivid_d, &mutGene_d, generator, POPULATION_SIZE);
		mutation<<<BLOCK,THREAD>>>(population_dev, state_random,
                                   mutIndivid_d, mutGene_d, POPULATION_SIZE);
        cudaDeviceSynchronize();
		
        /** evaluate fitness of individuals in population */
		fitness_evaluate<<<BLOCK,THREAD>>>(population_dev, points_dev,
                                           fitness_dev, POPULATION_SIZE);
        cudaDeviceSynchronize();
        
        /** select individuals for mating to create the next generation,
            i.e. sort population according to its fitness and keep
            fittest individuals first in population  */
        setIndexes<<<BLOCK,THREAD>>>(indexes_dev);
        cudaDeviceSynchronize();

#ifdef THRUST_REUSE_MALLOC
	cudaMallocReuse = true;
#endif

        thrust::sort_by_key(fitnesses_thrust, fitnesses_thrust+POPULATION_SIZE, indexes_thrust);

#ifdef THRUST_REUSE_MALLOC
	cudaMallocReuse = false;
#endif

        selection<<<BLOCK,THREAD>>>(population_dev, newPopulation_dev, indexes_dev);
        cudaDeviceSynchronize();
        
        //swap populations        
        float *tmp = population_dev;
        population_dev = newPopulation_dev;
        newPopulation_dev = tmp;
        

        /** time step evaluation - convergence criterion check */
        //get BEST FITNESS to host
        cudaMemcpy(&bestFitness, fitness_dev, sizeof(float), cudaMemcpyDeviceToHost);
        check_cuda_error("Coping fitnesses_dev[0] to host");
        
        //check if the fitness is decreasing or if we are stuck at local minima
        if(fabs(bestFitness - previousBestFitness) < 0.01f)
            noChangeIter++;
        else
            noChangeIter = 0;
        previousBestFitness = bestFitness;

        //log message
        #if defined(DEBUG)
        cout << "#" << generationNumber<< " Fitness: " << bestFitness << \
        " Iterations without change: " << noChangeIter << endl;
        #endif
	}

    int t2 = clock(); //stop timer

    /**
        Results
    */

    //get solution from device to host
    for(int i=0; i<INDIVIDUAL_LEN; i++){
        cudaMemcpy(&solution[i], &population_dev[i*POPULATION_SIZE],
                   sizeof(float), cudaMemcpyDeviceToHost);
        check_cuda_error("Coping solution to host");
    }

    *bestFitness_o = bestFitness;
    *genNumber_o = generationNumber;
    *time_o = (t2-t1)/(double)CLOCKS_PER_SEC;



    /**
        Free memory
    */
    cudaFree(points_dev);//input points
    cudaFree(fitness_dev);//fitness array
    cudaFree(indexes_dev);//key for sorting
    cudaFree(population_dev);
    cudaFree(newPopulation_dev);
    cudaFree(state_random);//state curand
    cudaFree(mutIndivid_d);//mutation probability
    cudaFree(mutGene_d);//mutation probability

    curandDestroyGenerator(generator);
}
