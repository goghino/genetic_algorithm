/**

Genetic algorithm for finding function aproximation. GPU accelerated version

Given data points {x, f(x)+noise} generated by noisy polynomial function
f(x) = c4*x^3 + c3*x^2 + c2*x + c1,
find unknown parameters c1, c2, c3 and c4.


Inputs:
• The set of points on a surface (500–1000);
• The size of population P (1000–2000);
• E_m , D_m – mean and variance for Mutation to generate the random number of mutated genes;
• maxIter - the maximum number of generations, 
  maxConstIter - the maximum number of generations with constant value of the best fitness.

Outputs:
• The time of processing on GPU;
• The set of coefficients of the polynomial that approximates the given set of points;
• The best fitness value;
• The last generation number (number of evaluated iterations).
*/

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <time.h>
#include <algorithm>

#include <cuda.h>
#include <curand.h>
#include <curand_kernel.h>
#include <thrust/sort.h>
#include <thrust/device_ptr.h>

#include "config.h"
#include "check.h"
#include "kernels.h"

void check_cuda_error(const char *message)
{
	cudaError_t err = cudaGetLastError();
	if (err != cudaSuccess)
	{
		printf("\033[31mERROR: %s: %s\n\033[0m", message, cudaGetErrorString(err));
		exit(1);
	}
}

using namespace std;

#define THREAD 128
#define BLOCK (POPULATION_SIZE / THREAD)

// Reads input file with noisy points. Points will be approximated by 
// polynomial function using GA.
static float *readData(const char *name, const int POINTS_CNT);

// Override cudaMalloc with our function call so that thrust::sort_by_key
// does not allocate/free working memory every iteration
extern __thread bool cudaMallocReuse;

/*
    ------------------------
    | Main body of the GA  |
    ------------------------
*/
int main(int argc, char **argv)
{
    if (argc != 2)
    {
        cout << "Usage: " << argv[0] << " inputFile" << endl;    
        return -1;
    }

    //read input data
    //points are the data to approximate by a polynomial
    float *points = readData(argv[1], N_POINTS);

    /**
        Allocations of memory
    */
    //device memory for holding input points
    float *points_dev;
    cudaMalloc(&points_dev, 2*N_POINTS*sizeof(float)); // [x, f(x)+err]
    check_cuda_error("Error allocating device memory");
    cudaMemcpy(points_dev, points, 2*N_POINTS*sizeof(float), cudaMemcpyHostToDevice);
    check_cuda_error("Error copying data");

    //arrays to hold old and new population    
    float *population_dev;
    cudaMalloc(&population_dev, POPULATION_SIZE * INDIVIDUAL_LEN * sizeof(float));
    check_cuda_error("Error allocating device memory");

    float *newPopulation_dev;
    cudaMalloc(&newPopulation_dev, POPULATION_SIZE * INDIVIDUAL_LEN * sizeof(float));
    cudaMemset(newPopulation_dev, 0, POPULATION_SIZE * INDIVIDUAL_LEN * sizeof(float));
    check_cuda_error("Error allocating device memory");

    //arrays that keeps fitness of individuals withing current population
    float *fitness_dev;
    cudaMalloc(&fitness_dev, POPULATION_SIZE*sizeof(float));
    check_cuda_error("Error allocating device memory");

    //key value for sorting
    int *indexes_dev;
    cudaMalloc(&indexes_dev, POPULATION_SIZE*sizeof(int));
    check_cuda_error("Error allocating device memory");

    curandState *state_random;
    cudaMalloc((void **)&state_random,POPULATION_SIZE * INDIVIDUAL_LEN * sizeof(curandState));
    check_cuda_error("Allocating memory for curandState");

    //mutation probabilities
    float* mutIndivid_d;
    cudaMalloc((void **) &mutIndivid_d,POPULATION_SIZE*sizeof(float));
    check_cuda_error("Allocating memory in mutIndivid_d");

    float* mutGene_d;
    cudaMalloc((void **)&mutGene_d,POPULATION_SIZE*INDIVIDUAL_LEN*sizeof(float));
    check_cuda_error("Allocating memory in mutGene_d");

    //create PRNG for generating mutation probabilities
    curandGenerator_t generator;

    curandCreateGenerator(&generator, CURAND_RNG_PSEUDO_DEFAULT);
    check_cuda_error("Error in curandCreateGenerator");

    curandSetPseudoRandomGeneratorSeed(generator, 0);
    check_cuda_error("Error in curandSeed");

    //recast device pointers into thrust copatible pointers
    thrust::device_ptr<int> indexes_thrust = thrust::device_pointer_cast(indexes_dev);
    thrust::device_ptr<float> fitnesses_thrust = thrust::device_pointer_cast(fitness_dev);


    //Initialize first population (with zeros or some random values)
    initCurand<<<BLOCK, THREAD>>>(state_random);
    initPopulation<<<BLOCK, THREAD>>>(population_dev, state_random); //<-5, 5>
    cudaDeviceSynchronize();

    /**
        Main GA loop
    */
    int t1 = clock(); //start timer

    int generationNumber = 0;
    int noChangeIter = 0;

    float bestFitness = INFINITY;
    float previousBestFitness = INFINITY;

	while ( (generationNumber < maxGenerationNumber)
            /*&& (bestFitness > targetErr)
            && (noChangeIter < maxConstIter) */)
	{
		generationNumber++;
	
        /** crossover first half of the population and create new population */
		crossover<<<BLOCK, THREAD>>>(population_dev, state_random);
        cudaDeviceSynchronize();

		/** mutate population and childrens in the whole population*/
        generateMutProbab(&mutIndivid_d, &mutGene_d, generator, POPULATION_SIZE);
        cudaDeviceSynchronize();
		mutation<<<BLOCK, THREAD>>>(population_dev, state_random,
                                    mutIndivid_d, mutGene_d, POPULATION_SIZE);
        cudaDeviceSynchronize();
		
        /** evaluate fitness of individuals in population */
		fitness_evaluate<<<BLOCK, THREAD>>>(population_dev,
                                            points_dev, fitness_dev,
                                            POPULATION_SIZE);
        cudaDeviceSynchronize();
        
        /** select individuals for mating to create the next generation,
            i.e. sort population according to its fitness and keep
            fittest individuals first in population  */
        setIndexes<<<BLOCK, THREAD>>>(indexes_dev);
        cudaDeviceSynchronize();

#ifdef THRUST_REUSE_MALLOC
	cudaMallocReuse = true;
#endif

        thrust::stable_sort_by_key(fitnesses_thrust, fitnesses_thrust + POPULATION_SIZE, indexes_thrust);

#ifdef THRUST_REUSE_MALLOC
	cudaMallocReuse = false;
#endif

        selection<<<BLOCK, THREAD>>>(population_dev, newPopulation_dev, indexes_dev);
        cudaDeviceSynchronize();
        
        //swap populations        
        float *tmp = population_dev;
        population_dev = newPopulation_dev;
        newPopulation_dev = tmp;

        /** time step evaluation - convergence criterion check */
        //get BEST FITNESS to host
        cudaMemcpy(&bestFitness, fitness_dev, sizeof(float), cudaMemcpyDeviceToHost);
        check_cuda_error("Coping fitnesses_dev[0] to host");
        
        //check if the fitness is decreasing or if we are stuck at local minima
        if(fabs(bestFitness - previousBestFitness) < 0.001f)
            noChangeIter++;
        else
            noChangeIter = 0;
        previousBestFitness = bestFitness;

#if defined(DEBUG)
        //log message
        cout << "#" << generationNumber<< " Fitness: " << bestFitness << \
        " Iterations without change: " << noChangeIter << endl;
#endif
	}

    int t2 = clock(); //stop timer

    cout << "------------------------------------------------------------" << endl;    
    cout << "Finished! Found Solution:" << endl;

    //get solution from device to host
    float *solution = new float[INDIVIDUAL_LEN];
    for(int i=0; i<INDIVIDUAL_LEN; i++){
        cudaMemcpy(&solution[i], &population_dev[i*POPULATION_SIZE],
                   sizeof(float), cudaMemcpyDeviceToHost);
    }
    check_cuda_error("Coping solution to host");
    
    //solution is first individual of population with the best params of a polynomial    
    cout << "\tc0 = " << solution[0] << endl
		<< "\tc1 = " << solution[1] << endl
		<< "\tc2 = " << solution[2] << endl
		<< "\tc3 = " << solution[3] << endl
		<< "Best fitness: " << bestFitness << endl
		<< "Generations: " << generationNumber << endl;

    cout << "Time for GPU calculation equals \033[35m"
        << (t2-t1)/(double)CLOCKS_PER_SEC << " seconds\033[0m" << endl;

    delete [] points;
    delete [] solution;

    cudaFree(points_dev);//input points
    cudaFree(fitness_dev);//fitness array
    cudaFree(indexes_dev);//key for sorting
    cudaFree(population_dev);
    cudaFree(newPopulation_dev);
    cudaFree(state_random);//state curand
    cudaFree(mutIndivid_d);//mutation probability
    cudaFree(mutGene_d);//mutation probability

    curandDestroyGenerator(generator);
    
    return 0;
}

//------------------------------------------------------------------------------

static float *readData(const char *name, const int POINTS_CNT)
{
    FILE *file = fopen(name, "r");
 
	float *points = new float[2 * POINTS_CNT]; 
    if (file)
    {
        //x, f(x)
        for (int k = 0; k < POINTS_CNT; k++)
        {
        	if (fscanf(file, "%f %f", &points[k], &points[POINTS_CNT + k]) == EOF)
        	{
        		cerr << "Unexpected end of input data" << endl;
        		exit(1);
        	}
		}
        fclose(file);
        cout << "Reading file - success!" << endl;
    }
    else
    {
        cerr << "Error while opening the file " << name << "!!!" << endl;
        delete [] points;
        exit(1);
    }

    return points;
}

