/**

Genetic algorithm for finding function aproximation. GPU accelerated version

Given data points {x, f(x)+noise} generated by noisy polynomial function
f(x) = c3*x^3 + c2*x^2 + c1*x + c0,
find unknown parameters c1, c2, c3 and c0.


Inputs:
• The set of points on a surface (500–1000);
• The size of population P (1000–2000);
• E_m , D_m – mean and variance for Mutation to generate the random number of mutated genes;
• maxIter - the maximum number of generations, 
  maxConstIter - the maximum number of generations with constant value of the best fitness.

Outputs:
• The time of processing on GPU;
• The set of coefficients of the polynomial that approximates the given set of points;
• The best fitness value;
• The last generation number (number of evaluated iterations).
*/

#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <time.h>
#include <algorithm>

#include <cuda.h>
#include <curand.h>
#include <curand_kernel.h>
#include <thrust/sort.h>

#include "mpi_version_multi.h"

#include "config.h"

using namespace std;

#define THREAD 128
#define BLOCK (POPULATION_SIZE/THREAD)

void check_cuda_error(const char *message)
{
        cudaError_t err = cudaGetLastError();
            if (err!=cudaSuccess){
             printf("\033[31mERROR: %s: %s\n\033[0m", message, cudaGetErrorString(err));
             exit(1);
            }
}


//------------------------------------------------------------------------------
//                       CUDA Kernel functions
//------------------------------------------------------------------------------

/**
    Initializes seed for CUDA random generator
*/
__global__ void initCurand(curandState *state)
{
    int id = blockDim.x * blockIdx.x + threadIdx.x;
    curand_init(6482, id, 0, &state[id]);
}


/**
    Initializes initial population by random values. Use range <-5.0, 5.0>
*/
__global__ void initPopulation(float *population, curandState *state)
{
    int id = blockDim.x * blockIdx.x + threadIdx.x;
    curandState localState = state[id];

    if(id < POPULATION_SIZE)
    {
        for(int i=0; i<INDIVIDUAL_LEN; i++)
            population[id + i*POPULATION_SIZE] = 10*curand_uniform(&localState) - 5;        
    }
}

/**
    An individual fitness function is the difference between measured f(x) and
    approximated polynomial g(x), built using individual's coeficients,
    evaluated on input data points.

    Smaller value means bigger fitness

    @size - number of individuals in current (sub)population
*/
__global__ void fitness_evaluate(float *individuals, float *points, float *fitness, int size)
{

    int idx = blockDim.x * blockIdx.x + threadIdx.x;
    if(idx >= size)
        return;

    float sumError = 0;

    //for every given data point
	for(int pt=0; pt<N_POINTS; pt++)
	{
		float f_approx = 0.;
		
        //for every polynomial parameter: Ci * x^(order)
		for (int order=0; order < INDIVIDUAL_LEN; order++)
		{
			f_approx += individuals[idx + order*size] * pow(points[pt], order);
		}

		sumError += pow(f_approx - points[N_POINTS+pt], 2);
	}
	
    //The lower value of fitness is, the better individual fits the model
	fitness[idx] = sumError;
}


/**
    Individual is set of coeficients c1-c4. 

    For example:
    parent1 == [0 0 0 0]
    parent2 == [1 1 1 1]
    crosspoint(random between 1 and 3) = 2
      then
    child1  = [0 0 1 1]
    child2  = [1 1 0 0]
*/

__global__ void crossover(float *population_dev, curandState *state)
{
    
    int idx = blockDim.x * blockIdx.x + threadIdx.x;

    //Replace only second half of the population by new individuals
    //created by crossover from the first half of the population
    if(idx >= POPULATION_SIZE || idx<POPULATION_SIZE/2)
        return;
   
    //randomly select two fit parrents for mating from the fittest half of the population
    curandState localState = state[idx];
	int parent1_i = (curand(&localState) % (POPULATION_SIZE/2));
	int parent2_i = (curand(&localState) % (POPULATION_SIZE/2));


    //select crosspoint, do not select beginning and end of individual as crosspoint
	int crosspoint = curand(&localState) % (INDIVIDUAL_LEN - 2) + 1 ;
	state[idx] = localState;

    //do actual crossover
    for(int j=0; j<crosspoint; j++)
    {
            population_dev[idx +j*POPULATION_SIZE]
                = population_dev[parent1_i + j*POPULATION_SIZE];
    }

    for (int j = crosspoint; j < INDIVIDUAL_LEN; j++)
    {

        population_dev[idx + j*POPULATION_SIZE]
            = population_dev[parent2_i + j*POPULATION_SIZE];
    
    }
}

/**
    Mutation is addition of noise to genes, given mean and stddev.

    probabilities of mutating individuals and their 
    genes is computed before calling this kernel
    @mutGene
    @mutIndivid
    @size - number of individuals in current (sub)population

    For example(binary representation of genes):
    individual == [1 1 1 1]
    mutNumber = 2
    loop 2 times:
       1st: num_of_bit_to_mutate = 2
            inverse individuals[2]   ->   [1 1 0 1] 
       2nd: num_of_bit_to_mutate = 0
            inverse individuals[0]   ->   [0 1 0 1]
    return mutated individual         [0 1 0 1]
*/
__global__ void mutation(float *individuals, curandState *state,
                         float* mutIndivid, float* mutGene, int size)
{
    int idx = blockDim.x*blockIdx.x + threadIdx.x;

    curandState localState = state[idx];
    
    //first individual is not mutated to keep the best solution unchanged    
    if(idx >= size || idx < 1)
        return;

    float mutationRate = mutIndivid[idx];

    for(int j=0; j<INDIVIDUAL_LEN; j++)
    {
        int flip_idx = idx + j*size;
        //probability of mutating gene 
        if(mutGene[flip_idx] < mutationRate) {
            individuals[flip_idx] += 0.01*(2*curand_uniform(&localState)-1);
        } 
    }

    state[idx] = localState;
}

/**
    Sets up indexes for thrust::sort_by_key
*/
__global__ void setIndexes(int *indexes)
{
    int idx = blockDim.x * blockIdx.x + threadIdx.x;

    if (idx>=POPULATION_SIZE) 
        return;

    indexes[idx] = idx;
}


/*
    population - sorted individuals according to their fitness

	individuals with small (good) fitness value are put to the beginning 
	individuals with large (bad) fitness value are placed at the end;
*/
__global__ void selection(float *population, float *newPopulation, int* indexes)
{
    int idx = blockDim.x * blockIdx.x + threadIdx.x;

    //only first half needs to be placed in sorted manner
    //second half will be overwritten anyway
    if(idx > POPULATION_SIZE/2)
        return;

    //reorder population so that fittest individuals are first
    for (int j=0; j<INDIVIDUAL_LEN; j++)
    {
        newPopulation[idx + j*POPULATION_SIZE]
            = population[indexes[idx] + j*POPULATION_SIZE];
    }
}


//------------------------------------------------------------------------------
//                 Encapsulating GPU functions for kernel calls
//------------------------------------------------------------------------------

/*
    Initialize population with random values. All workload is done on
    master process.
*/
void doInitPopulation(float *population_dev, curandState *state_random)
{
    int block = POPULATION_SIZE/THREAD;
    initCurand<<<block, THREAD>>>(state_random);
    initPopulation<<<block, THREAD>>>(population_dev, state_random); //<-5, 5>
}

/**
    Crossover population, all workload is done on master process.
*/
void doCrossover(float *population_dev, curandState* state_random)
{
    int block = POPULATION_SIZE/THREAD;
    crossover<<<block,THREAD>>>(population_dev, state_random);
    cudaDeviceSynchronize();
}

/**
    Mutate population, performed on local portion of population on each process
    @size - number of individuals to process
*/
void doMutation(float *population_dev, curandState *state_random,
                float *mutIndivid_d, float *mutGene_d, int size)
{
    //TODO size%thread != 0
    int block = size/THREAD;
    mutation<<<block,THREAD>>>(population_dev, state_random,
                                mutIndivid_d, mutGene_d, size);
    cudaDeviceSynchronize();
		
}		

/**
    Evaluate fitness of each individual from population,
    performed on local portion of population on each process

    @size - number of individuals to process
*/
void doFitness_evaluate(float *population_dev, float *points_dev, float *fitness_dev,
                        int size)
{
    int block = size/THREAD;

    fitness_evaluate<<<block,THREAD>>>(population_dev, points_dev, fitness_dev, size);
    cudaDeviceSynchronize();
}

/**
    Sort individuals according to fitness value
*/
void doSelection(thrust::device_ptr<float>fitnesses_thrust,
                 thrust::device_ptr<int>indexes_thrust, int *indexes_dev,
                 float *population_dev, float* newPopulation_dev)
{
    int block = POPULATION_SIZE/THREAD;

    setIndexes<<<block,THREAD>>>(indexes_dev);
    cudaDeviceSynchronize();

    //sort fitness array
    thrust::sort_by_key(fitnesses_thrust, fitnesses_thrust+POPULATION_SIZE, indexes_thrust);

    //reorder population according to fitness values
    selection<<<block,THREAD>>>(population_dev, newPopulation_dev, indexes_dev);
    cudaDeviceSynchronize();
}
